---
title: 쓰기 패턴과 마이그레이션 비용으로 외래키를 고르는 기준
description: 외래키 기본값을 유지하되, 쓰기 빈도와 마이그레이션 비용, 쿼리 형태를 함께 보고 무결성 경계를 정한 기록.
pubDate: 2023-12-06T14:22:27+00:00
source: twitter
tags:
  - database
  - postgres
  - schema
  - performance
  - data-integrity
---

외래키를 무조건 쓰거나 무조건 피하는 기준은 운영 환경에서 오래 버티기 어려웠다. 나도 처음에는 FK를 안 거는 설계를 이해하기 힘들었다. 그런데 운영 테이블에 외래키 필드를 추가하고 제약을 생성하는 과정에서 몇 분 동안 읽기 락이 걸리는 걸 겪고 생각이 바뀌었다. 제약의 정답을 찾는 문제라기보다, 어떤 시점과 부하에서 적용하느냐를 먼저 설계해야 하는 문제에 가까웠다.

그래도 기본 선택은 FK를 초반부터 거는 쪽이다. 데이터 무결성을 디비가 일관되게 검사해 주고, 서비스마다 검증 코드를 중복으로 작성할 일을 줄여 준다. 논리 ERD와 물리 스키마가 벌어지면서 생기는 팀 내 컨텍스트 비용도 줄어든다. 다만 쓰기 빈도가 높은 구간에서는 제약 검사 오버헤드가 병목이 될 수 있어서, 일부 경우는 애플리케이션 로직이나 배치 검증으로 보완하는 선택이 현실적이다. 이때는 성능 수치만 보지 말고, 불일치가 생겼을 때 복구 가능한 경계까지 같이 정해야 했다.

마이그레이션과 쿼리 형태는 별개가 아니었다. 큰 테이블에 뒤늦게 제약을 추가하면 기능 배포보다 락 영향과 검증 시간이 더 큰 리스크가 된다. 그래서 제약 도입은 가능한 초기에 끝내고, 늦어졌다면 작업 창과 영향 범위를 먼저 계산해야 했다. 쿼리에서도 같은 일이 있었다. PostgreSQL에서 대용량 테이블의 `datetime` 컬럼을 `date`로 캐스팅해 조건을 걸면 인덱스가 작동하지 않아 체감이 약 20배 느려질 수 있었다. 가능하면 `datetime` 자체로 범위 조건을 만들고, 캐스팅이 꼭 필요하면 함수 인덱스를 별도로 준비하는 쪽이 안전했다.

결국 무결성은 한 기능으로 해결되지 않는다. FK를 쓰면 검증 구현 비용은 줄지만 마이그레이션 비용을 관리해야 하고, FK를 비우면 쓰기 여지는 생기지만 정합성 운영 비용을 직접 감당해야 한다. 여기에 쿼리 형태까지 맞춰야 실제 장애를 줄일 수 있다. 엔진 버전이나 데이터 분포에 따라 락 동작과 실행 계획이 달라질 수 있다는 점은 남는 한계라, 규칙을 외우기보다 현재 쓰기 패턴과 변경 비용을 기준으로 경계를 정하는 방법이 더 실용적이었다.
