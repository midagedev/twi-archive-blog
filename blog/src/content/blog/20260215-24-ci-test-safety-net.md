---
title: 레거시 코드 손대기 전에 안전망부터 깔았던 이유
description: 테스트 부재와 느슨한 타입, 방치된 코드가 유지보수 비용을 키운 경험을 바탕으로 CI 게이트와 타입/정리 우선순위를 정리했다.
pubDate: 2023-05-01T23:52:20+00:00
source: twitter
tags:
  - legacy-code
  - testing
  - ci
  - type-safety
  - maintenance
---

레거시를 다루며 가장 크게 착각했던 건 “코드가 낡아서 어렵다”는 설명이었다. 시간이 지나 보니 본질은 더 단순했다. 테스트가 없거나 너무 적었다. 작은 개선 하나 넣으면 예상 못 한 오류가 연달아 나왔고, 그 경험이 쌓이면서 코드를 좋게 바꾸기보다 망가뜨리지 않는 데만 집중하게 됐다. 새로 만드는 수밖에 없다고 생각했던 시기도 있었지만, 돌이켜보면 우선순위를 잘못 잡았다. 기능 추가보다 먼저 실패를 빨리 알려주는 장치가 필요했다.

타입도 같은 문제를 드러냈다. 변수명 하나 바꾸는 작업을 백엔드부터 프론트엔드까지 꽤 꼼꼼히 리뷰했는데, 중간의 `any` 캐스팅 구간 하나 때문에 끝내 누락이 남았다. 리뷰를 열심히 해도 정적 검증이 비어 있으면 사람 눈은 쉽게 빠진다. 그래서 결론은 간단했다. 테스트와 타입 중 하나는 반드시 있어야 하고, 가능하면 둘 다 갖춰야 한다. 최소한 `any`를 편의가 아니라 위험 신호로 보기 시작하면, 수정 범위를 읽는 방식이 달라진다.

2025년 7월에는 그 대가를 다시 확인했다. CI에서 테스트를 돌리지 않던 사이, 일주일 전에 넣어둔 테스트 두 개가 이미 깨져 있었다. 그날 유닛, 통합, E2E 케이스를 한 번에 정리했고 다음 날 파이프라인에 넣기로 했다. 핵심은 누가 깨뜨렸는지 탓하려는 게 아니라, 깨진 순간을 팀이 바로 보게 만드는 것이다. 실패를 초기에 드러내면 수정 비용이 작고, 브랜치가 오래 벌어지기 전에 대화를 시작할 수 있다.

여기에 하나를 더하면 유지보수 피로가 더 줄었다. 쓰지 않는데 남아 있는 코드는 나중에 다시 읽을 때마다 “정말 안 쓰이나?”라는 확인 비용을 반복해서 만든다. 이 비용은 조용히 누적되고 결국 실수 확률로 돌아온다. 메인 브랜치와 작업 브랜치의 간극을 작게 유지하는 습관도 같은 맥락이다. 코드 품질뿐 아니라 리뷰와 의사소통 비용을 함께 낮춘다. 레거시에 손대기 전 체크리스트를 하나만 남긴다면 이 정도다. CI 테스트 게이트를 먼저 세우고, 느슨한 타입 경계를 줄이고, 안 쓰는 코드는 바로 지운다. 이 세 가지가 만능은 아니지만, 방어적 코딩에 갇히는 속도는 확실히 늦춰준다.
