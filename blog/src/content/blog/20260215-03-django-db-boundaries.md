---
title: Django에서 DB와 애플리케이션 경계를 정하는 기준
description: ORM 로딩, FK 제약, 마이그레이션, 도메인 검증을 실제 운영 맥락에서 어디에 둘지 정리한 기록
pubDate: 2023-10-26T05:02:17+00:00
source: twitter
tags:
  - django
  - database
  - orm
  - validation
  - backend
---

Django를 오래 쓰면서 가장 자주 부딪힌 건 기능 구현보다 경계 결정이었다. 어떤 책임을 DB에 두고, 어떤 책임을 애플리케이션으로 올릴지 매번 다시 판단해야 했다. 특히 ORM 로딩 전략, FK 제약, 마이그레이션 방식, 도메인 검증이 서로 얽히면 정답이 아니라 운영 조건에 맞는 선택이 필요했다.

예전에는 `select_related`보다 `prefetch_related`를 더 안전한 기본값처럼 봤다. 그런데 요청 빈도가 높은 주요 쿼리셋에 prefetch 대상 모델이 20개 가까이 붙고 캐시까지 흔들리자, 앱 서버에서 객체를 조립하는 비용이 눈에 띄게 커졌다. 그때는 조인을 DB에 맡기는 `select_related`가 더 나은 지점이 분명히 있었다. 반대로 이 경험이 곧바로 prefetch를 피하자는 결론은 아니었다. DB 스케일아웃은 보통 어렵고 앱 서버 확장은 상대적으로 쉬워서, 트래픽 패턴과 캐시 상태를 같이 보고 둘을 섞어 쓰는 쪽이 현실적이었다.

FK도 비슷했다. 한때는 FK가 없으면 조인이 느릴 거라고 막연히 생각했는데, 실제로는 조인 성능과 FK 존재는 같은 문제가 아니었다. FK는 조회 최적화 장치라기보다 DML 시점의 참조 무결성 제약에 가깝다. 그래서 어떤 팀은 마이그레이션 리스크를 줄이려고 FK를 약하게 두거나 아예 피하기도 한다. 이 선택은 기술 취향보다 운영 절차, 배포 방식, 장애 복구 전략과 같이 봐야 했다.

검증 로직은 더 명확했다. DB 제약만으로 표현되지 않는 규칙은 계속 늘어났고, 결국 애플리케이션 계층의 검증이 필요했다. Django 기본 이메일 validator처럼 표준을 존중하고 싶어도 실제 입력 데이터를 처리하다 보면 완화가 필요한 순간이 생긴다. 모델 `save`에서 m2m를 다루기 어려워 create 액션에 트랜잭션을 두고 `on_commit` 후속 처리로 정리한 적도 있는데, 구현 코드는 줄었지만 테스트는 오히려 지저분해졌다. 정확한 성능 수치나 단일 해법은 없었다. 대신 지금은 기준을 고정해 두었다. 조회 비용은 DB와 앱에 분산해 측정 가능한 쪽으로, 무결성은 FK와 운영 절차를 함께 고려해, 도메인 규칙은 DB 제약과 애플리케이션 검증을 계층화해 관리한다.
