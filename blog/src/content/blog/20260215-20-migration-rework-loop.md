---
title: 마이그레이션 과소추정이 재작업 루프로 번질 때 정리한 기준
description: 짧게 끝낼 줄 알았던 마이그레이션과 기능 개발이 왜 반복 재작성과 긴 QA 안정화로 이어졌는지, 그 과정에서 바꾼 실행 기준을 정리했다.
pubDate: 2024-10-24T12:18:50+00:00
source: twitter
tags:
  - migration
  - refactoring
  - qa
  - ai-assisted-dev
---

Svelte4에서 Svelte5로 옮길 때 처음에는 2~3일이면 끝날 거라고 봤다. 실제로는 10일이 걸렸다. 출발은 문법 변경이었지만, 꼬여 있던 양방향 바인딩을 건드리자 상태 변경 흐름을 같이 정리하지 않으면 다음 단계로 못 갔다. 결국 마이그레이션과 리팩토링이 한 덩어리가 됐고, 일정 예측은 처음 가정부터 틀렸다.

30시간을 쓴 기능 개발도 같은 패턴이었다. 10시간 들인 1차 시도는 머지하지 못한 채 방치되다 폐기했고, 다시 10시간 들여 만든 버전도 구조를 이해한 뒤 버렸다. 마지막 10시간에서야 형태가 잡혔다. 겉으로 보면 비효율이지만, 덜 맞는 설계를 억지로 붙였으면 이후 수정 비용이 더 커졌을 가능성이 높다. 문제는 실패가 아니라, 실패를 늦게 인정해서 되감기 루프를 길게 만든 점이었다.

AI 보조 구현도 기대만큼 단순하지 않았다. 스프링은 패턴이 정형화되어 있으니 캐시 적용은 빠를 거라 생각했는데, 인메모리 캐시와 Redis를 같이 쓰는 테스트에서 빈 주입 오류를 끝내 못 풀었다. 코드 생성 속도는 분명 도움이 됐지만, 테스트 컨텍스트 경계와 의존성 조합은 사람이 먼저 설계해야 했다. 특히 조합이 늘어나는 구간은 "한 번에 생성"보다 "가정 명시 후 작은 검증"이 안정적이었다.

출시 직전에는 QA가 일주일 내내 이슈를 확인해줬고, 하나 고치면 이전에 되던 동작이 다시 깨지는 회귀가 반복됐다. 그래서 지금은 일정 산정부터 바꿨다. 문법 교체 시간만 잡지 않고 상태 모델 정리, 회귀 테스트 보강, QA 안정화 시간을 기본 포함한다. 구현은 큰 덩어리로 밀지 않고 되돌리기 쉬운 단위로 자르고, 각 단위에서 기존 동작 보존을 먼저 확인한다. 도메인과 팀 맥락은 공개된 정보가 제한적이라 일반화한 부분이 있지만, 재작업 루프를 줄이는 데는 이 기준이 가장 현실적이었다.
