---
title: "결말은 개발자1이 말을 안듣는 와중에 개발자2를 투입해서 리뷰 보완작업을 하다가 PR들 간에 컨플릭트가 잔뜩 나버렸고 결국 모든"
description: 초기 단계에서 병렬 PR과 에이전트 보완 작업이 왜 충돌로 끝났는지, 그리고 순차 메인라인으로 복귀한 판단 기준을 정리했다.
pubDate: 2025-07-16T23:28:26+00:00
source: twitter
tags:
  - 개발프로세스
  - PR전략
  - 협업
  - LLM에이전트
---

초기 프로젝트에서 병렬 PR을 밀어붙였다가 팀 전체가 한 번에 멈춘 적이 있었다. 개발자1이 기존 흐름을 따르지 않는 상태에서 개발자2를 추가로 투입해 리뷰 보완을 붙였고, 그 결과 PR 사이 충돌이 빠르게 누적됐다. 결국 모든 PR을 abandon하고 다시 시작했다. 이 장면은 특정 도구 하나의 실패라기보다, 경계가 아직 굳지 않은 초반에 흔히 나는 통합 실패에 더 가까웠다.

문제의 핵심은 “누가 더 빨리 코드를 쓰느냐”가 아니었다. 기능 의존성이 높은데도 작업을 병렬로 쪼갠 설계가 먼저 흔들렸고, 리뷰 단계가 품질 확인이 아니라 뒤늦은 통합 지점이 되어버렸다. 여기에 에이전트 기반 보완 작업까지 겹치면 브랜치 간 문맥 차이가 더 커진다. 이슈 하나를 여러 워크트리로 동시에 밀면 작업 흐름을 추적하기 어렵다는 경험도 같은 맥락이었다. 코드 품질 평가는 결국 산출물보다 중간 의사결정의 밀도에 좌우됐다.

복구는 단순하게 갔다. 초기에는 한두 명 선발대가 main에 직접, 작은 단위로 연속 커밋하며 진도를 내는 방식으로 바꿨다. 병렬화보다 통합 비용을 낮추는 쪽을 우선했다. 의도가 몇 번의 프롬프트 안에서 맞지 않으면 /clear하고 다시 시작하는 원칙도 같이 적용했다. 사람 협업에서도 한참 어긋난 뒤에 억지로 맞추기보다, 초반에 맥락을 비우고 재정렬하는 편이 비용이 낮았다.

이 방식의 장점은 명확했다. 충돌 해결에 쓰던 시간이 줄고, 변경의 책임선이 또렷해졌다. 다만 한계도 있다. main 직커밋은 팀 규모가 작고 변경 반경이 좁은 초기에만 효율이 높다. 기간이 길어지거나 참여자가 늘면 보호장치 없는 속도전이 된다. 공개된 맥락에는 코드베이스 규모나 정확한 기간 정보가 없어서, 이 결론을 모든 팀에 그대로 일반화할 수는 없다.

적용 기준은 단순하다. 의존성이 크고 순차 작업이 많은 구간이면 병렬 PR보다 순차 메인라인이 낫다. 반대로 경계가 안정되고 소유권이 분명해진 뒤에 PR 병렬화를 늘려야 충돌 비용이 통제된다. 오케스트레이션이나 하네스 같은 운영 복잡도는 “할 수 있느냐”보다 “지금 우리 맥락에서 감당할 가치가 있느냐”로 판단해야 한다. 초반에는 구조보다 흐름을 먼저 고정하는 쪽이 대체로 안전했다.
