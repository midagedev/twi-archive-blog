---
title: 레거시 변경 공포를 줄인 순서, 테스트에서 시작한 리팩토링
description: 테스트가 거의 없던 레거시에서 반복 회귀를 겪은 뒤, 테스트 구조화와 CI 강제, 모듈 분리를 어떤 순서로 적용했는지 정리했다.
pubDate: '2023-05-01T23:52:20+00:00'
source: twitter
tags:
  - 레거시
  - 테스트
  - CI
  - 리팩토링
---

레거시를 다루면서 가장 크게 착각했던 건 문제의 본질을 코드 연식에서 찾은 점이었다. 돌아보면 핵심은 테스트케이스가 없거나 극단적으로 적었던 구조였다. 작은 개선 하나에 오류가 여러 개 따라왔고, 그 경험이 쌓이며 코드는 방어적으로 굳었다. 변수명 하나 바꾸는 작업도 백엔드와 프론트엔드를 함께 리뷰했는데 누락이 남았고, 추적해보니 중간 `any` 캐스팅으로 안전망이 끊겨 있었다. 리뷰만으로는 부족했고, 테스트나 타입 중 하나는 반드시 실패를 자동으로 알려줘야 했다.

운영 루틴도 같은 문제를 드러냈다. CI에서 테스트를 돌리지 않던 기간에는 지난주에 추가한 테스트 두 개가 이미 깨진 채 지나갔다. 그래서 테스트를 새것/기존것으로 정리하고 유닛, 통합, E2E를 목적별로 다시 묶었다. 여기서 중요한 건 분류 자체가 아니라 실행 강제였다. 다음 단계로 이 묶음을 CI 파이프라인에 넣고, 깨뜨린 변경이 바로 드러나도록 알림 흐름을 붙였다. 사람의 주의력 대신 파이프라인이 기본 검증을 맡게 만든 셈이다.

리팩토링 리소스에 대한 반발이 예상될 때는 범위를 작게 잘랐다. 모듈 분리를 시작한 날도 PR을 만들자마자 동료 한 분과 대면 리뷰를 먼저 하고, 영향 범위를 제한한 상태로 배포했다. 큰 선언보다 작은 증거를 쌓는 쪽이 납득을 얻기 쉬웠다. 레거시를 한 번에 교체하려고 하면 논쟁이 커지는데, 경계를 나눠 사이드프로젝트 다루듯 옮기면 위험과 커뮤니케이션 비용을 함께 줄일 수 있었다.

여기에 안 쓰는 코드를 제때 걷어내는 습관을 더하니 실수 빈도가 내려갔다. 폐기되지 않은 코드는 나중에 다시 읽을 때마다 사용 여부를 재판단하게 만들고, 그 비용이 누적된다. 지금의 기준은 단순하다. 회귀가 잦은 구간에 최소 테스트를 먼저 세우고, CI로 강제하고, 모듈 경계를 분리하고, 미사용 코드를 지운다. 배포 규모나 팀 구조 같은 세부 수치는 기록에 남아 있지 않아 일반화는 조심해야 하지만, 이 순서는 일정 압박이 있을 때도 비교적 흔들리지 않았다.
