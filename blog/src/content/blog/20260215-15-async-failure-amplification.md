---
title: 비동기 경로에서 실패가 증폭될 때 세운 기준
description: SQS 재시도 버그로 테스트 메시지 1건이 5분 만에 300만 건으로 불어난 경험을 바탕으로, 비동기·분산 경로에서 실패를 제한하고 복구 가능성을 높이는 운영 기준을 정리했다.
pubDate: 2025-06-11T10:00:24+00:00
source: twitter
tags:
  - backend
  - distributed-systems
  - sqs
  - observability
  - postmortem
---

EKS에서 SQS 컨슈머를 처음 붙였을 때, 문제는 처리량이 아니라 실패 처리 경로였다. 메시지 풀러 코드를 잘못 배포했고 롤백 대비로 남겨둔 기존 노드가 메시지를 계속 가져가면서 소비 경로가 겹쳤다. 이어서 실패한 큐를 지우지 않고 서킷브레이커를 피해 같은 SQS로 다시 넣는 버그가 겹치자, 테스트 메시지 1건이 5분 만에 300만 건으로 증식했다. CPU 부하 기반 오토스케일링까지 동시에 반응해 노드 수가 늘어나면서, 장애는 원인보다 증폭 구조가 더 큰 문제가 됐다.

그 뒤로는 비동기라고 자동으로 안전해진다는 기대를 버렸다. 서비스 간 HTTP 호출에서는 길 잃은 요청으로 타임아웃이 잦았고, 메시지 브로커로 넘긴 작업은 로그 없이 사라지기도 했다. API 명세 변경이 늦게 반영되면 로그인 실패나 상품 이용 불가로 바로 이어졌다. Datadog을 붙여도 트레이스가 구간마다 끊기면 장애는 탐지보다 해석이 더 어렵다. 실패는 한 번 발생하고 끝나는 사건이 아니라, 관측 공백과 재시도 정책을 타고 시스템 전체로 전파되는 흐름에 가깝다.

이후 운영 기준은 단순하게 잡았다. 소비자는 같은 큐로 즉시 재투입하지 않고, 재시도는 별도 경로에서 횟수와 간격을 강제한다. 메시지에는 멱등 키를 두고 상태 전이를 `received`, `processing`, `failed`, `dead-lettered`처럼 남겨 추적을 복원한다. 배포 시에는 컨슈머 종료 훅으로 폴링을 먼저 멈추고 in-flight 처리를 정리해, 롤백 노드가 메시지를 다시 채가지 않게 한다. API 변경은 버전 호환 구간을 두고, 호출 실패는 타임아웃·재시도·서킷브레이커를 한 세트로 검증한다.

완전히 해결됐다고 말하기는 어렵다. MongoDB처럼 RDS 클러스터 엔드포인트와 다른 연결 모델에서는 노드 유지보수나 DNS 캐싱 이슈로 연결이 끊길 수 있어, 커넥션 수명은 짧게 두고 요청 재시도를 기본값으로 가져가야 했다. 불확실성은 남지만 한 가지는 분명해졌다. 비동기와 분산 경로에서 중요한 건 실패를 “없애는” 기술보다 실패가 커지는 속도와 범위를 제한하는 설계다. 장애 크기를 줄여야 복구가 운영 가능한 문제로 내려온다.
