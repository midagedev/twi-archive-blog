---
title: "@Fin__nn 우리가 좀 레이어를 얇게 쓰긴 했죠."
description: "레이어를 언제 두껍게 만들지, 모델 검증을 어디에 둘지, 편의 패턴이 규모에서 깨지는 지점을 정리한 기록."
pubDate: 2023-03-26T01:37:22+00:00
source: twitter
tags:
  - 아키텍처
  - 레이어링
  - 도메인모델
  - 검증
  - 유지보수
---

처음에는 레이어를 얇게 쓰는 선택이 대부분 맞았다. 화면이나 API를 빨리 붙이고 흐름을 확인해야 할 때는 물리 모델 중심 구조가 가장 빠르다. 문제는 시간이 지나 비즈니스 규칙이 늘어났을 때다. 이때 팀이 자주 겪는 실패가 둘이다. 아직 필요 없는데 도메인 모델과 서비스 레이어를 미리 깔아 복잡도를 선반영하거나, 반대로 이미 필요해졌는데도 얇은 구조를 유지해 규칙이 여기저기 새는 경우다.

복잡한 규칙이 보이면 나는 검증 위치부터 정한다. 예를 들어 type이 a면 price는 1000 이상, b면 미만이어야 하는 조건은 입력 경로가 몇 개든 같은 규칙이다. 그런데 type과 price를 바꾸는 메서드가 여러 개면, 각 메서드에서 따로 막는 방식은 금방 누수가 난다. 그래서 가능한 한 모델 레벨에서 불변식을 묶고, 서비스 레이어는 유스케이스 조합과 트랜잭션 경계에 집중시키는 편이 유지보수 비용이 낮았다.

프로토타입 단계에서의 매직은 분명히 이득이 있다. 코드가 짧고 빨라 보이고, provide 같은 편의 패턴도 당장은 손이 덜 간다. 하지만 수십 명이 교체되며 코드를 만지고 규모가 커지면 숨은 규칙의 비용이 편의성을 넘어선다. props 키와 provide 키를 반드시 맞춰야 하는 식의 제약은 처음엔 사소하지만, 시간이 지나면 디버깅 포인트를 늘린다. 적게 쓰는 문법보다, 누가 봐도 같은 방식으로 읽히는 구조가 더 오래 버틴다.

결국 기준은 기술 취향이 아니라 변경 비용이었다. 같은 검증이 여러 경로에서 반복되기 시작하면 레이어를 하나 올리고, 아직 규칙이 단순하면 얇게 유지한다. 오류 가능성이 낮은 덩어리로 나누고, 추상화 수준이 높은 도구를 써서 실수를 줄이는 쪽이 실무에서는 자주 이겼다. 성능은 중요한 주제지만, 대개는 먼저 구조를 정돈해 운영 리스크를 낮춘 뒤에 다뤄도 늦지 않았다. 정확한 분기점은 팀과 도메인마다 다르다는 점만 분명히 두고 판단하면 된다.
