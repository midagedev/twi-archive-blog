---
title: 재현되지 않는 운영 버그를 다루는 순서
description: 고객 PC 한정 실패, 모호한 서드파티 요청, 봇 트래픽 오인을 겪으며 정리한 실전 디버깅 워크플로우.
pubDate: 2023-02-15T14:08:17+00:00
source: twitter
tags:
  - debugging
  - production
  - incident
  - observability
  - backend
---

운영에서 오래 끄는 건 재현이 안 되는 버그다. CDN 이미지를 axios로 blob으로 받는 흐름이 특정 고객 PC에서만 두세 번째 파일부터 실패한 적이 있었다. 응답은 200인데 중간 어디선가 abort되는 느낌이었고, 앱 내부 가설을 여러 개 털어도 닫히지 않았다. 이때 핵심은 원인 추측을 늘리는 게 아니라 경계를 먼저 정리하는 일이었다. 브라우저 안에서 설명이 안 되면 OS와 네트워크로 수사 범위를 옮겨야 한다.

서드파티 연동에서도 같은 원칙이 통했다. 상대가 우리 서버로 요청을 보내는 구조인데 문서가 모호해서 작업이 멈췄다. 문서 업데이트를 기다리는 대신 요청 원문을 받는 간이 수집 지점을 먼저 만들었다. ChatGPT로 수신 코드를 만든 뒤 Lambda 함수 URL에 올리고 CloudWatch에서 실제 요청 상세를 확인했다. 추측성 대화가 줄고, 어떤 필드가 실제로 오는지부터 확정할 수 있었다.

트래픽 해석도 가정이 틀리면 바로 흔들린다. 페이스북 크롤러가 헤드리스 브라우저처럼 동작하면서 setTimeout 세션 체크 스크립트를 전부 트리거해 DAU가 2만까지 튄 적이 있다. "사용자만 이 스크립트를 실행한다"는 전제가 깨지면 지표와 부하 판단이 같이 틀어진다. 그래서 봇 유입을 기본 시나리오에 넣고, 실행 조건과 지표를 분리해 읽는 습관이 필요했다.

지금은 플레이북을 단순하게 유지한다. 재현이 안 되면 기능 수정부터 하지 않고, 경계와 실행 주체를 먼저 좁힌다. 문서가 애매하면 임시 엔드포인트로 실제 요청을 캡처한다. 가설이 소진되면 브라우저 밖으로 넘어간다. 그리고 사고가 겹치는 날일수록 기본 위생을 자동화한다. API 키를 실수로 커밋한 날처럼, 이런 실수는 디버깅 난이도와 무관하게 복구 비용을 키운다. 이번 케이스도 abort 지점은 끝내 확정하지 못했지만, 앱 책임 범위를 분리한 덕분에 다음 대응 기준은 더 선명해졌다.
