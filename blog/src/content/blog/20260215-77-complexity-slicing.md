---
title: 작은 조각과 명확한 신호로 복잡도 다루기
description: 기능 수보다 결합 수가 먼저 문제를 키운다는 전제에서, 배포 단위를 자르고 데드코드를 일정 신호로 읽는 운영 기준을 정리했다.
pubDate: 2023-10-17T16:10:22+00:00
source: twitter
tags:
  - architecture
  - delivery
  - management
  - complexity
---

최근에 일을 정리하면서 다시 확인한 건, 복잡도는 기능 개수보다 기능 사이 결합에서 더 빨리 커진다는 점이다. 기능이 3개일 때의 부담과 6개일 때의 부담은 단순히 두 배가 아니었다. 1+2+3과 1+2+3+4+5+6의 체감 차이처럼, 문제 후보가 급격히 늘어난다. 같은 6개라도 3개씩 경계를 나눠 격리하면 다뤄야 할 면이 줄어든다. 내가 설계를 볼 때 먼저 보는 것도 기능 목록보다 경계선이다.

그래서 구현보다 먼저 배포 단위를 자른다. 의존성이 없는 피처라면 함께 테스트하고 함께 배포해야 한다는 습관부터 의심한다. 효용이 낮은 피처를 기다리느라 바로 가치가 나는 피처를 늦추면, 팀은 바쁜데 제품은 느려진다. 일하는 방식도 비슷했다. 큰 컨텍스트 하나를 오래 붙드는 것보다, 얇은 컨텍스트 여러 개를 들고 짧게 전진하는 편이 전환 비용이 낮고 흐름이 덜 끊겼다.

이 관점에서 데드코드는 개인 과오라기보다 일정 운영 신호에 가깝다. 코드가 남았다는 사실만 지적하면 같은 일이 반복된다. 왜 남길 수밖에 없었는지, 어떤 약속이 정리 시간을 계속 밀어냈는지를 같이 봐야 한다. 과도한 일정 요구, 묶음 배포 강제, 후속 정리를 항상 다음 스프린트로 넘기는 구조가 있으면 데드코드는 자연스럽게 쌓인다. 그래서 나는 데드코드를 보면 코드 자체보다 우선순위와 릴리스 규칙을 먼저 점검한다.

설계 원칙도 같다. 객체지향은 결과로 드러날 때는 깔끔하지만, 객체지향적으로 짜야 한다는 목표가 앞서면 불필요한 추상화가 늘기 쉬웠다. 결국 YAGNI를 자주 어기게 된다. 필요한 흐름을 먼저 작게 통과시키고, 반복이 확인될 때만 추상화를 올리는 순서가 실제로 덜 복잡했다. 이 방식이 모든 팀에 같은 효과를 보장한다고 말할 수는 없다. 도메인 결합이 강한 영역은 분리 비용이 더 클 수 있다. 그래도 내가 계속 유지하는 기준은 같다. 작게 자르고, 독립적으로 내보내고, 남은 코드를 관리 신호로 읽는 것.
