---
title: "후..."
description: "가볍게 시작한 업그레이드가 왜 리팩토링과 QA 부채로 커지는지, 실제 시행착오에서 정리한 범위·순서·테스트 기준."
pubDate: 2024-10-07T10:08:36+00:00
source: twitter
tags:
  - engineering
  - upgrade
  - refactoring
  - testing
  - qa
---

업그레이드는 자주 “문법만 바꾸면 끝”으로 시작한다. 나도 Svelte4에서 5로 올릴 때 2~3일이면 정리될 줄 알았는데, 실제로는 10일째 붙잡고 있었다. 표면은 버전 변경이었지만 안쪽에는 오래 쌓인 양방향 바인딩, 모호한 상태 변경, 화면별 예외 처리들이 엉켜 있었다. 단순 작업처럼 보인다는 이유로 범위를 가볍게 잡으면, 일정은 계획표가 아니라 코드 구조가 다시 정한다는 걸 먼저 맞게 된다.

중간에 방향을 바꿨다. 문법 치환만 하고 지나가면 다음 수정 때 같은 지점을 또 밟는다는 게 분명했다. 그래서 바인딩을 정리하고 상태 변경 경로를 드러내는 리팩토링을 같이 넣었다. Django에서도 비슷한 장면이 있었다. save 오버라이드에서 m2m 후처리를 억지로 다루기보다, create 액션에 트랜잭션을 두고 on_commit으로 후속 처리를 분리하니 코드는 짧아졌다. 대신 테스트는 더 까다로워졌다. 실행 타이밍이 갈라지는 순간부터 검증 포인트가 늘어난다.

결과는 “빨리 끝냈다”와 거리가 멀었다. 기능 하나를 마쳤다고 생각하면 QA에서 예전에 되던 흐름이 다시 깨졌고, 하나 고치면 다른 곳이 흔들렸다. 실제로 한 기능에 10시간씩 세 번을 다시 쓰면서 앞선 시도를 두 번 버린 적도 있었다. 돌아보면 구현 속도의 문제가 아니라, 초반 범위 정의와 검증 순서를 느슨하게 잡은 비용이 뒤에서 한꺼번에 청구된 셈이었다. 그 비용은 일정만이 아니라 팀과 QA의 피로로도 남는다.

요즘은 업그레이드를 치환 작업이 아니라 경계 재정의 작업으로 다룬다. 시작 전에 문법 변경 범위와 동반 리팩토링 범위를 분리해서 적고, 단계마다 회귀 체크 지점을 먼저 고정한다. 트랜잭션이나 커밋 타이밍처럼 테스트가 쉽게 지저분해지는 구간은 처음부터 통합 테스트 비중을 높여 설계한다. 코드베이스 크기나 팀 상황이 달라 정답을 단정할 수는 없지만, 최소한 일정 추정에는 구현 시간만이 아니라 검증 비용까지 포함해야 같은 실수를 덜 반복한다.
