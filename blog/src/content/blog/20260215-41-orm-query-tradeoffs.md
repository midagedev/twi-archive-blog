---
title: "select_related(db단 Join)가 prefetch_related에 비해 장점이 뭐가 있는지 잘 몰랐었는데(심지어 팀내"
description: "ORM 조회 전략을 고를 때 join/prefetch 논쟁보다 병목 위치와 스키마 의미를 먼저 보는 기준을 정리했다."
pubDate: 2023-10-26T05:02:17+00:00
source: twitter
tags:
  - django
  - orm
  - database
  - query
  - domain-model
---

한동안 나는 ORM에서 `prefetch_related`를 거의 기본값처럼 썼고, 팀 안에도 `select_related`를 지양하는 분위기가 있었다. 그래서 둘의 차이를 단순히 쿼리 수 문제로만 봤다. 그런데 요청 빈도가 높은 구간에서 캐시 이슈가 생기고, 주요 queryset에 prefetch 대상 모델이 20개 안팎으로 붙어 있던 시점을 지나면서 관점이 바뀌었다. 핵심은 prefetch가 맞냐 틀리냐가 아니라, 어떤 계층이 그 부하를 받는지가 먼저라는 점이었다.

`select_related`는 조인을 DB에서 처리해 한 번에 읽고, `prefetch_related`는 여러 결과를 앱에서 조합한다. 평소에는 캐시와 prefetch 조합이 실무에서 충분히 효율적일 때가 많다. 다만 캐시가 흔들리는 순간에는 앱 쪽 조립 비용이 바로 드러나고, 그때는 DB가 잘하는 일을 DB에 넘기는 선택이 유효해진다. 그렇다고 prefetch를 일반적으로 피해야 한다는 뜻은 아니었다. 당시 부담은 높은 요청량, 넓은 prefetch 범위, 캐시 장애가 동시에 겹친 맥락에 가까웠다.

스키마 쪽에서도 오래된 오해를 정리했다. 예전에는 FK로 선언되지 않은 조인은 느릴 거라고 막연히 생각했는데, 조회 성능을 그렇게 단순하게 설명할 수는 없었다. FK는 본질적으로 DML 시점의 참조 무결성 제약에 가깝고, 조회 성능 판단의 기준과는 결이 다르다. 같은 맥락에서 DB 레벨 제약만으로는 점점 늘어나는 업무 규칙을 모두 검증하기 어렵다. 규칙이 늘수록 애플리케이션 계층의 검증이 필요해지고, 논리 ERD와 물리 ERD 사이의 갭 자체도 운영 비용이 된다.

지금은 선택 기준을 이렇게 둔다. join과 prefetch는 취향이 아니라 병목 위치로 고른다. FK 유무를 조회 튜닝의 만능 신호로 보지 않는다. DB 제약이 못 담는 규칙은 도메인 로직에서 명시하고, ERD를 분리해 컨텍스트를 늘릴 때는 그 비용을 넘는 이득이 있는지 먼저 확인한다. 당시 케이스의 정량 지표를 별도로 남기지는 못했지만, 최소한 `항상 prefetch`나 `항상 join` 같은 규칙이 실제 시스템에서는 가장 위험한 단순화라는 점은 분명히 배웠다.
