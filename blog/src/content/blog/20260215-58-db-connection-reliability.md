---
title: "@masan_aje 드라이버 기본값이 리트라이를 해서 문제가 없는게 맞아야 하는데 한주동안 몽고디비에 쿼리 날리는데서 200개 이"
description: "리트라이에 가려진 소켓 에러를 커넥션 수명과 재사용 설정, 쿼리 관측 기준으로 줄여간 기록"
pubDate: 2024-04-04T08:50:32+00:00
source: twitter
tags:
  - database
  - reliability
  - incident
  - connection
  - django
---

드라이버 기본 리트라이가 있으니 큰 문제는 없을 거라고 봤는데, 운영 데이터는 다르게 나왔다. 한 주 동안 몽고디비 쿼리 구간에서 200개가 넘는 요청이 소켓 에러로 실패했고 500 응답이 떨어졌다. 클라이언트에도 리트라이가 있어서 최종 사용자 영향은 줄었을 수 있지만, 서버 안에서는 실패가 계속 누적됐다. 이때부터 리트라이는 안정성 자체가 아니라 증상을 늦추는 장치로 보고 다루기 시작했다.

원인 분석은 깔끔하게 끝나지 않았다. 당시에는 리드 레플리카 동기화 시점에 지연 작업이 겹치거나, 장애 판단 이후 자동 복구 과정에서 커넥션을 끊는 시나리오를 의심했다. 다만 결정적인 근거는 확보하지 못했다. 느린 쿼리, 과도한 트랜잭션, 데드락 같은 전형적인 신호도 뚜렷하지 않았다. 확신 없는 단정보다 재현 범위를 줄이고 연결 계층부터 통제하는 쪽이 현실적이었다.

실행은 커넥션 정책을 먼저 고정하는 순서로 갔다. 예전에 Aurora Postgres를 쓸 때는 클러스터 엔드포인트가 프록시 역할을 일부 흡수했고, 커넥션 최대 수명을 1분 정도로 짧게 둔 설정이 버티는 데 도움이 됐다. 프레임워크 기본값도 다시 확인했다. 장고는 기본 설정에서 커넥션 풀을 적극적으로 쓰지 않기 때문에, 최소한 커넥션 재사용 설정을 명시해 연결 생성과 종료의 흔들림을 줄였다.

추가로 쿼리 관측 기준도 바꿨다. explain에서 date 조건은 인덱스 스캔이 없고 datetime 조건에서만 인덱스 스캔이 보인 사례가 있었다. ORM에서는 쿼리셋 evaluate 시점과 prefetch 동작을 분리해서 봐야 한다는 것도 다시 확인했다. 연결 문제와 쿼리 문제는 장애 순간에 한 덩어리로 보이기 쉽다. 지금도 비슷한 이슈를 다룰 때는 단일 원인 확정에 집착하기보다, 커넥션 수명·재사용·쿼리 실행 시점 로그를 먼저 맞춰 복구 시간을 줄이는 데 집중한다.
