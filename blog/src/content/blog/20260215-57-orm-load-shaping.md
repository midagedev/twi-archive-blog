---
title: "select_related(db단 Join)가 prefetch_related에 비해 장점이 뭐가 있는지 잘 몰랐었는데(심지어 팀내"
description: "팀 관행으로 prefetch_related를 주로 쓰던 환경에서, 캐시 장애와 고빈도 요청을 겪으며 select_related와 데이터 모델링 트레이드오프를 다시 정리한 기록."
pubDate: "2024-12-03T02:40:59+00:00"
source: twitter
tags:
  - django
  - orm
  - backend
  - database
  - performance
---

팀 안에는 한동안 `select_related`를 지양하는 분위기가 있었다. 나도 `prefetch_related`가 더 안전한 기본값이라고 생각했고, DB 조인의 장점을 명확히 설명하지 못했다. 캐시가 정상일 때는 이 선택이 크게 문제를 만들지 않았다. 그래서 어떤 부하를 앱 레이어에서 처리하고, 어떤 부하는 DB에 맡길지 기준을 세밀하게 나눌 필요를 덜 느꼈다.

상황이 달라진 건 주요 queryset에 prefetch 대상 모델이 약 20개까지 붙은 구간에서였다. 요청 빈도가 높은데 캐시 이슈가 겹치면서, 단순 쿼리 수보다도 앱에서 객체를 모으고 조립하는 비용이 먼저 크게 드러났다. 이 경험으로 `prefetch_related` 자체를 경계하게 된 건 아니다. 다만 관계를 한 가지 방식으로만 읽는 습관이 운영 리스크를 키울 수 있다는 점은 분명해졌다.

그래서 항상 함께 읽는 FK/OneToOne 경로는 `select_related`로 옮겨 DB가 조인을 처리하게 했다. 반대로 컬렉션 성격이 강하거나 엔드포인트별 접근 패턴이 갈리는 관계는 `prefetch_related`를 유지했다. 핵심은 둘 중 하나를 신념처럼 고정하지 않는 것이었다. DB 스케일아웃은 보통 어렵고 앱 서버 확장은 상대적으로 쉬우니, DB에 넘길 범위도 요청 특성과 장애 시나리오를 함께 보고 제한해야 했다.

이 과정에서 오래된 오해도 정리됐다. FK로 선언되지 않으면 조인이 본질적으로 느릴 거라고 막연히 생각했는데, FK는 주로 참조 무결성을 위한 DML 제약이다. 조인 전략과 성능 판단은 결국 쿼리 형태와 실행 계획으로 확인해야 했다. 또 논리 ERD와 물리 ERD 사이에 의도적으로 갭을 만들면 그만큼 설명과 유지 비용이 늘어난다. 이 비용을 넘는 이득이 있을 때만 구조를 복잡하게 가져가는 편이 낫다.

결론은 단순하다. 캐시 상태, 요청 빈도, 관계 접근 패턴, 변경 비용을 같이 보고 `select_related`와 `prefetch_related`를 섞어 쓴다. 당시 케이스의 정량 벤치마크를 충분히 남기진 못해 절대적 우열 수치로 일반화하긴 어렵다. 대신 주요 경로는 단순하게, 변동이 큰 경로는 분리해서 다룬다는 원칙은 이후에도 재사용하기 쉬웠다.
