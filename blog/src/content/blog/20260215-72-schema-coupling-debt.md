---
title: 공유 타입과 무마이그레이션 데이터가 만드는 숨은 결합 부채
description: 같은 언어 스택의 공유 타입, 늦은 경계 분리, 무마이그레이션 스키마 변경, 과한 확장성 선투자가 어떻게 유지보수 부채로 돌아오는지 정리했다.
pubDate: 2025-07-31T10:02:08+00:00
source: twitter
tags:
  - architecture
  - technical-debt
  - schema
  - backend
---

NestJS처럼 프론트와 백엔드가 같은 언어를 쓰면 시작 속도는 확실히 빠르다. 문제는 그 속도 때문에 데이터베이스 물리 모델 타입을 전 레이어에서 그대로 공유하기 쉬워진다는 점이다. 초반에는 생산성이 높아 보이지만, 도메인이 늘어나 물리 모델을 경계별로 나눠야 할 시점을 자주 놓친다. 그 순간부터 필드 하나의 변경이 API, 화면, 배치로 연쇄 전파되고 결합도가 급격히 올라간다.

원래 언어가 분리된 스택은 경계를 먼저 의식하게 되는데, 단일 언어 스택에서는 “나중에 정리하자”가 더 쉽게 허용된다. 시간이 지나 담당자가 바뀌면 이 부채는 거의 항상 땜질로 유지된다. 그래서 규모가 커지기 시작하면 DB 모델, 도메인 모델, 응답 스키마를 의도적으로 분리하고, 변환 코드를 명시적으로 두는 편이 안전하다. 중복처럼 보이는 코드가 오히려 변경 범위를 줄여준다.

무스키마 저장소를 쓰면 이 규율이 더 중요해진다. MongoDB에서 마이그레이션 없이 스키마를 계속 바꾸면 데이터 자체가 부채가 된다. 코드에는 과거 형태와 현재 형태를 동시에 처리하는 분기가 쌓이고, 여러 서비스가 같은 데이터를 공유할수록 해석 규칙이 달라진다. 반대로 변경마다 작은 마이그레이션을 운영하면, 적어도 분기 증가 속도를 통제할 수 있다.

또 하나는 확장성 선투자다. 언젠가 다국어가 필요할 것 같아 i18n을 먼저 넣고, 언젠가 DB를 바꿀지 몰라 과한 추상화를 만들고, 언젠가 인프라를 옮길 거라 이중 코드를 유지한다. 실제 변화가 오지 않으면 남는 건 복잡성뿐이다. 어려운 결정을 미룬 비용을 팀이 매일 유지보수로 갚게 된다.

정리할 때 기준은 단순하다. 지금 확실한 요구에는 구체적으로 최적화하고, 나중에 바뀔 가능성은 거대한 추상화 대신 교체 지점을 작게 남긴다. 그리고 저장소 종류와 무관하게 스키마 변경은 마이그레이션 단위로 관리한다. 이 방식은 화려하진 않지만 팀이 바뀌어도 시스템이 버티는 시간을 늘려준다. 다만 비기술 조직에서는 이 비용을 설명하고 합의하는 일이 가장 큰 난점으로 남는다.
