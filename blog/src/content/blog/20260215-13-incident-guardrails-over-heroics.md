---
title: 반복 실수를 막는 운영 가드레일
description: 런타임 오해, 무심한 update, 리트라이 착시를 겪으며 정리한 재발 방지 기준
pubDate: 2023-04-13T21:40:43+00:00
source: twitter
tags:
  - engineering
  - incident
  - backend
  - operations
  - guardrails
---

운영에서 반복되는 문제를 보면 대부분 “당연히”라는 가정에서 시작됐다. 사인 로직은 클라이언트에서만 동작할 거라고 보고 useEffect 다루듯 붙였다가 서버를 꺼뜨린 적이 있었다. 백오피스에서는 오류 보고가 들어와 빨리 찾았지만, 같은 문제가 고객 서비스 경로에서 났다면 탐지가 훨씬 늦었을 가능성이 컸다. 결국 코드 한 줄보다, 실행 위치와 경계를 확인하지 않은 습관이 더 큰 원인이었다.

이후에는 복구 속도보다 재발 방지 장치를 먼저 두는 쪽으로 바꿨다. 가장 단순하지만 효과가 컸던 건 데이터 변경 전 count 확인이었다. update 전에 대상을 세면 피해 범위를 즉시 가늠할 수 있고, 중단 기준도 미리 정할 수 있다. 당시 건별 영향 범위나 복구 시간은 기록이 충분하지 않아 단정할 수 없지만, 적어도 무증상으로 오래 퍼지는 상황은 줄었다.

리트라이는 “안전장치”가 아니라 “경고신호”로 보게 됐다. 드라이버 기본 재시도와 클라이언트 재시도가 겹치면 겉보기 성공률이 높아져 문제가 가려지기 쉽다. 실제로 한 주 동안 몽고DB 쿼리 구간에서 200건이 넘는 소켓 에러와 500 응답이 있었는데, 재시도 덕분에 사용자 체감 이슈가 작아 보였을 뿐 근본 원인은 남아 있었다. 그래서 성공 응답만 보지 않고 원시 에러와 재시도 횟수를 함께 본다.

배치 작업은 도메인 규칙으로 이상 징후를 잡는다. 같은 사용자에게 완전히 같은 메일이 반복 발송되면 비정상으로 판단하는 식이다. 완벽한 규칙은 아니고 예외도 있지만, 단순한 기준이 초기에 사고를 자주 막아준다. 여기에 에러를 계속 사람에게 중계하는 구조를 줄이고, 시스템이 에러를 보고 고치고 다시 확인하는 루프를 붙이면 대응 효율이 올라간다. 런타임 가정 검증, update 전 count, retry 가시화, 배치 이상 규칙 이 네 가지는 스택이 달라도 바로 적용 가능한 최소 가드레일이었다.
